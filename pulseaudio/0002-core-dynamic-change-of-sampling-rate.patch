From d5eb6c3a3f0aff20644e6169372207c427ff84ef Mon Sep 17 00:00:00 2001
From: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
Date: Wed, 5 Jan 2011 10:46:28 -0600
Subject: [PATCH 2/2] core: dynamic change of sampling rate

This patch implements a dynamic change of sampling rates. To
avoid glitches, this change is only enabled when sinks and sources are
suspended. Additional work may be needed to prevent system sounds and
alerts from reconfiguring the sample rate.

Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
---
 src/modules/alsa/alsa-sink.c   |   14 +++++++++++
 src/modules/alsa/alsa-source.c |   14 +++++++++++
 src/pulsecore/sink-input.c     |   25 ++++++++++++++++++++
 src/pulsecore/sink.c           |   49 ++++++++++++++++++++++++++++++++++++++++
 src/pulsecore/sink.h           |    6 +++++
 src/pulsecore/source-output.c  |   22 ++++++++++++++++++
 src/pulsecore/source.c         |   39 +++++++++++++++++++++++++++++++
 src/pulsecore/source.h         |    5 ++++
 8 files changed, 174 insertions(+), 0 deletions(-)

Index: pulseaudio-1.0/src/modules/alsa/alsa-sink.c
===================================================================
--- pulseaudio-1.0.orig/src/modules/alsa/alsa-sink.c
+++ pulseaudio-1.0/src/modules/alsa/alsa-sink.c
@@ -1541,6 +1541,19 @@ static pa_bool_t sink_set_formats(pa_sin
     return TRUE;
 }
 
+static pa_bool_t sink_update_rate_cb(pa_sink *s, uint32_t rate)
+{
+    struct userdata *u = s->userdata;
+    pa_assert(u);
+
+    if (!PA_SINK_IS_OPENED(s->state)) {
+        pa_log("Updating rate for device %s, new rate is %d",u->device_name, rate);
+        u->sink->sample_spec.rate = rate;
+        return TRUE;
+    }
+    return FALSE;
+}
+
 static int process_rewind(struct userdata *u) {
     snd_pcm_sframes_t unused;
     size_t rewind_nbytes, unused_nbytes, limit_nbytes;
@@ -2171,6 +2184,7 @@ pa_sink *pa_alsa_sink_new(pa_module *m,
         u->sink->update_requested_latency = sink_update_requested_latency_cb;
     u->sink->set_state = sink_set_state_cb;
     u->sink->set_port = sink_set_port_cb;
+    u->sink->update_rate = sink_update_rate_cb;
     u->sink->userdata = u;
 
     pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
Index: pulseaudio-1.0/src/modules/alsa/alsa-source.c
===================================================================
--- pulseaudio-1.0.orig/src/modules/alsa/alsa-source.c
+++ pulseaudio-1.0/src/modules/alsa/alsa-source.c
@@ -1340,6 +1340,19 @@ static void source_update_requested_late
     update_sw_params(u);
 }
 
+static pa_bool_t source_update_rate_cb(pa_source *s, uint32_t rate)
+{
+    struct userdata *u = s->userdata;
+    pa_assert(u);
+
+    if (!PA_SOURCE_IS_OPENED(s->state)) {
+        pa_log("Updating rate for device %s, new rate is %d", u->device_name, rate);
+        u->source->sample_spec.rate = rate;
+        return TRUE;
+    }
+    return FALSE;
+}
+
 static void thread_func(void *userdata) {
     struct userdata *u = userdata;
     unsigned short revents = 0;
@@ -1871,6 +1884,7 @@ pa_source *pa_alsa_source_new(pa_module
         u->source->update_requested_latency = source_update_requested_latency_cb;
     u->source->set_state = source_set_state_cb;
     u->source->set_port = source_set_port_cb;
+    u->source->update_rate = source_update_rate_cb;
     u->source->userdata = u;
 
     pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
Index: pulseaudio-1.0/src/pulsecore/sink-input.c
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/sink-input.c
+++ pulseaudio-1.0/src/pulsecore/sink-input.c
@@ -366,6 +366,18 @@ int pa_sink_input_new(
     pa_assert(pa_sample_spec_valid(&data->sample_spec));
     pa_assert(pa_channel_map_valid(&data->channel_map));
 
+    if (!(data->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+        !pa_sample_spec_equal(&data->sample_spec, &data->sink->sample_spec)) {
+        /* try to change sink rate. This is done before the FIXATE hook since
+           module-suspend-on-idle can resume a sink */
+
+        pa_log("sink_input_new: Trying to change sample rate");
+        if (pa_sink_update_rate(data->sink, data->sample_spec.rate) == TRUE)
+            pa_log("sink_input_new: Rate changed");
+        else
+            pa_log("sink_input_new: Resampling enabled");
+    }
+
     /* Due to the fixing of the sample spec the volume might not match anymore */
     pa_cvolume_remap(&data->volume, &original_cm, &data->channel_map);
 
@@ -1601,6 +1613,19 @@ int pa_sink_input_finish_move(pa_sink_in
         return -PA_ERR_NOTSUPPORTED;
     }
 
+    if (!(i->flags & PA_SINK_INPUT_VARIABLE_RATE) &&
+        !pa_sample_spec_equal(&i->sample_spec, &dest->sample_spec)) {
+        /* try to change dest sink rate if possible without glitches.
+           module-suspend-on-idle resumes destination sink with
+           SINK_INPUT_MOVE_FINISH hook */
+
+        pa_log("sink_input_finish_move: Trying to change sample rate");
+        if (pa_sink_update_rate(dest, i->sample_spec.rate) == TRUE)
+            pa_log("sink_input_finish_move: Rate changed");
+        else
+            pa_log("sink_input_finish_move: Resampling enabled");
+    }
+
     if (i->thread_info.resampler &&
         pa_sample_spec_equal(pa_resampler_output_sample_spec(i->thread_info.resampler), &dest->sample_spec) &&
         pa_channel_map_equal(pa_resampler_output_channel_map(i->thread_info.resampler), &dest->channel_map))
Index: pulseaudio-1.0/src/pulsecore/sink.c
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/sink.c
+++ pulseaudio-1.0/src/pulsecore/sink.c
@@ -1313,6 +1313,54 @@ void pa_sink_render_full(pa_sink *s, siz
 }
 
 /* Called from main thread */
+pa_bool_t pa_sink_update_rate(pa_sink *s, uint32_t rate)
+{
+
+    if (PA_SINK_IS_OPENED(s->state)) {
+        pa_log("Cannot update rate, SINK_IS_OPENED");
+        return FALSE; /* cannot reconfigure an IDLE or RUNNING sink without glitches */
+    }
+
+    if (s->monitor_source) {
+        if (PA_SOURCE_IS_OPENED(s->monitor_source->state) == TRUE) {
+            pa_log("Cannot update rate, monitor source is OPENED");
+        }
+    }
+
+    if (s->update_rate) {
+
+        uint32_t desired_rate = rate;
+        uint32_t default_rate = s->core->default_sample_spec.rate;
+        uint32_t alternate_rate = s->core->alternate_sample_rate;
+        pa_bool_t use_alternate = FALSE;
+
+        if (default_rate%4000) {
+            /* default is a 11025 multiple */
+            if ((alternate_rate%4000==0) && (desired_rate%4000==0))
+                use_alternate=TRUE;
+        } else {
+            /* default is 4000 multiple */
+            if ((alternate_rate%11025==0) && (desired_rate%11025==0))
+                use_alternate=TRUE;
+        }
+
+        if (use_alternate)
+            desired_rate = alternate_rate;
+        else
+            desired_rate = default_rate;
+
+        if (s->update_rate(s, desired_rate) == TRUE) {
+            /* update monitor source as well */
+            if (s->monitor_source)
+                pa_source_update_rate(s->monitor_source, desired_rate);
+            pa_log("Changed sampling rate successfully ");
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/* Called from main thread */
 pa_usec_t pa_sink_get_latency(pa_sink *s) {
     pa_usec_t usec = 0;
 
Index: pulseaudio-1.0/src/pulsecore/sink.h
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/sink.h
+++ pulseaudio-1.0/src/pulsecore/sink.h
@@ -233,6 +233,10 @@ struct pa_sink {
      * set). Makes a copy of the formats passed in. */
     pa_bool_t (*set_formats)(pa_sink *s, pa_idxset *formats); /* may be NULL */
 
+      /* Called whenever the sampling frequency shall be changed. Called from main
+     * thread. */
+    pa_bool_t (*update_rate)(pa_sink *s, uint32_t rate);
+
     /* Contains copies of the above data so that the real-time worker
      * thread can work without access locking */
     struct {
@@ -403,6 +407,8 @@ unsigned pa_device_init_priority(pa_prop
 
 /**** May be called by everyone, from main context */
 
+pa_bool_t pa_sink_update_rate(pa_sink *s, uint32_t rate);
+
 /* The returned value is supposed to be in the time domain of the sound card! */
 pa_usec_t pa_sink_get_latency(pa_sink *s);
 pa_usec_t pa_sink_get_requested_latency(pa_sink *s);
Index: pulseaudio-1.0/src/pulsecore/source-output.c
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/source-output.c
+++ pulseaudio-1.0/src/pulsecore/source-output.c
@@ -347,6 +347,15 @@ int pa_source_output_new(
     /* Due to the fixing of the sample spec the volume might not match anymore */
     pa_cvolume_remap(&data->volume, &original_cm, &data->channel_map);
 
+    if (!(data->flags & PA_SOURCE_OUTPUT_VARIABLE_RATE) &&
+        !pa_sample_spec_equal(&data->sample_spec, &data->source->sample_spec)){
+        /* try to change source rate. This is done before the FIXATE hook since
+           module-suspend-on-idle can resume a source */
+
+        pa_log("Trying to change sample rate");
+        pa_source_update_rate(data->source, data->sample_spec.rate);
+    }
+
     if (data->resample_method == PA_RESAMPLER_INVALID)
         data->resample_method = core->resample_method;
 
@@ -1383,6 +1392,19 @@ int pa_source_output_finish_move(pa_sour
         return -PA_ERR_NOTSUPPORTED;
     }
 
+    if (!(o->flags & PA_SOURCE_OUTPUT_VARIABLE_RATE) &&
+        !pa_sample_spec_equal(&o->sample_spec, &dest->sample_spec)){
+        /* try to change dest sink rate if possible without glitches.
+           module-suspend-on-idle resumes destination source with
+           SOURCE_OUTPUT_MOVE_FINISH hook */
+
+        pa_log("source_output_finish_move: Trying to change sample rate");
+        if (pa_source_update_rate(dest, o->sample_spec.rate) == TRUE)
+            pa_log("source_output_finish_move: Rate changed");
+        else
+            pa_log("source_output_finish_move: Resampling enabled");
+    }
+
     if (o->thread_info.resampler &&
         pa_sample_spec_equal(pa_resampler_input_sample_spec(o->thread_info.resampler), &dest->sample_spec) &&
         pa_channel_map_equal(pa_resampler_input_channel_map(o->thread_info.resampler), &dest->channel_map))
Index: pulseaudio-1.0/src/pulsecore/source.c
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/source.c
+++ pulseaudio-1.0/src/pulsecore/source.c
@@ -150,6 +150,7 @@ static void reset_callbacks(pa_source *s
     s->update_requested_latency = NULL;
     s->set_port = NULL;
     s->get_formats = NULL;
+    s->update_rate = NULL;
 }
 
 /* Called from main context */
@@ -908,6 +909,44 @@ void pa_source_post_direct(pa_source*s,
 }
 
 /* Called from main thread */
+pa_bool_t pa_source_update_rate(pa_source *s, uint32_t rate)
+{
+
+    if (PA_SOURCE_IS_OPENED(s->state)) {
+        pa_log("Cannot update rate, SOURCE_IS_OPENED");
+        return FALSE; /* cannot reconfigure an IDLE or RUNNING source without glitches */
+    }
+
+    if (s->update_rate) {
+        uint32_t desired_rate = rate;
+        uint32_t default_rate = s->core->default_sample_spec.rate;
+        uint32_t alternate_rate = s->core->alternate_sample_rate;
+        pa_bool_t use_alternate = FALSE;
+
+        if (default_rate%4000) {
+            /* default is a 11025 multiple */
+            if ((alternate_rate%4000==0) && (desired_rate%4000==0))
+                use_alternate=TRUE;
+        } else {
+            /* default is 4000 multiple */
+            if ((alternate_rate%11025==0) && (desired_rate%11025==0))
+                use_alternate=TRUE;
+        }
+
+        if (use_alternate)
+            desired_rate = alternate_rate;
+        else
+            desired_rate = default_rate;
+
+        if (s->update_rate(s, rate) == TRUE) {
+            pa_log("Changed sampling rate successfully ");
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/* Called from main thread */
 pa_usec_t pa_source_get_latency(pa_source *s) {
     pa_usec_t usec;
 
Index: pulseaudio-1.0/src/pulsecore/source.h
===================================================================
--- pulseaudio-1.0.orig/src/pulsecore/source.h
+++ pulseaudio-1.0/src/pulsecore/source.h
@@ -178,6 +178,10 @@ struct pa_source {
      * in descending order of preference. */
     pa_idxset* (*get_formats)(pa_source *s); /* ditto */
 
+    /* Called whenever the sampling frequency shall be changed. Called from main
+     * thread. */
+    pa_bool_t (*update_rate)(pa_source *s, uint32_t rate);
+
     /* Contains copies of the above data so that the real-time worker
      * thread can work without access locking */
     struct {
@@ -358,6 +362,7 @@ pa_bool_t pa_source_get_mute(pa_source *
 pa_bool_t pa_source_update_proplist(pa_source *s, pa_update_mode_t mode, pa_proplist *p);
 
 int pa_source_set_port(pa_source *s, const char *name, pa_bool_t save);
+pa_bool_t pa_source_update_rate(pa_source *s, uint32_t rate);
 
 unsigned pa_source_linked_by(pa_source *s); /* Number of connected streams */
 unsigned pa_source_used_by(pa_source *s); /* Number of connected streams that are not corked */
